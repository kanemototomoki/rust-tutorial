- `!`付きは関数ではなくマクロを呼んでいる
  - e.g. `!println!()`
- `cargo new {pj_name}`で新しいプロジェクトの作成
- `cargo build`でビルド
- `cargo run`でコンパイルから実行まで
- `cargo check`バイナリは生成せずにビルドする watch的な
- `cargo doc --open`でドキュメント生成&open

- ライブラリクレートを追加するには`Cargo.toml`の`[dependencies]`セクションに追加する
- `match`式は一般的なエラー処理で使う
- **命名はスネークケース**
- parameter = 仮引数
- argument = 実引数
  - 絶対忘れるわこれ

## 所有権_スタックとヒープ
- スタックは重ねられたお皿のようなもの
  - 上に重ねていって、必要になったら上から取っていく
  - 上から取っていくだけなので高速
  - その代わり、既知の固定サイズでなくてはならない
- ヒープはコンパイル時にサイズが確定していなかったり可変のデータを置く場所
  - OSがヒープ上に十分な大きさの領域を確保し、**ポインタ**を返す
  - ポインタの場所が遠いと遅くなる
  - allocateする(メモリを確保する？)
- いちいち所有権を異動してたら大変なので**参照**がある
  - `&` 参照
  - `*` 参照外し
  - 参照した値は不変になる
    - だが`&mut`で可変にできる
    - 同じスコープで一つしか借用できない
    - 不変で借用後に可変で借用もだめ
- `&str`は文字列リテラルのスライス

## 所有権規則
- Rust上の各値は**所有者**と呼ばれる変数と対応している
- いかなる時も所有者はひとつ
- 所有者がスコープから外れたら値は破棄される

## 構造体(struct)
- `impl(implementation)`でメソッド定義
  - `self`がthis
  - 関連関数を生やせる(コンストラクタ運用)
    - selfを引数に取らない, `::`で呼び出す(`String::from`みたいな感じ)

## 型
### スカラー型(JSでいうプリミティブ？)
- 整数
  - 8bit~128bitまである
  - e.g. i8, u8
  - iが符号付き(-の可能性もある)
  - arch: isize, usizeはプログラムが依存しているOSの種類に依存する(64 or 32)
- 浮動小数点数
  - f32, f64
- 論理値
- 文字

### 複合型
- タプル
  - それぞれが別の型でもOK
  ```rust
  fn main() {
      let x: (i32, f64, u8) = (500, 6.4, 1);

      let five_hundred = x.0;

      let six_point_four = x.1;

      let one = x.2;
  }
  ```
- 配列
  - 全て同じ型じゃないとダメ
  - 固定長
  - 配列か**ベクタ型**で迷ったらベクタ型を使う
